name: Reusable Gemini Reviewer

on:
  workflow_call:
    secrets:
      GEMINI_API_KEY:
        required: true

jobs:
  review:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Gemini Libs
        run: npm install @google/generative-ai @octokit/rest

      - name: Run Review
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          REPO_OWNER: ${{ github.repository_owner }}
          REPO_NAME: ${{ github.event.repository.name }}
          BASE_BRANCH: ${{ github.base_ref }}
        run: |
          cat << 'EOF' > reviewer.js
          const { GoogleGenerativeAI } = require("@google/generative-ai");
          const { Octokit } = require("@octokit/rest");
          const { execSync } = require("child_process");

          // 1. GLOBAL RULES FETCHER
          async function getGlobalRules(owner) {
            try {
                // Adjust branch 'main' if your default branch is different (e.g., 'master')
                const url = `https://raw.githubusercontent.com/${owner}/infra/main/GEMINI.md`;
                console.log(`üìñ Fetching global rules from: ${url}`);
                const response = await fetch(url);
                if (!response.ok) return "";
                const text = await response.text();
                // Ensure we got actual text, not an error page
                return text.length < 10 ? "" : `\n\n### üåç USER-DEFINED GLOBAL STANDARDS\nYou MUST enforce these rules strictly:\n${text}\n`;
            } catch (e) {
                console.warn("‚ö†Ô∏è Failed to load GEMINI.md global rules.");
                return "";
            }
          }

          async function postOrUpdateComment(octokit, body) {
            const owner = process.env.REPO_OWNER;
            const repo = process.env.REPO_NAME;
            const issue_number = Number(process.env.PR_NUMBER);

            const { data: comments } = await octokit.issues.listComments({ owner, repo, issue_number });
            const botComment = comments.find(c => c.body.includes("## ü§ñ AI Code Review") || c.body.includes("## üü© LGTM!"));

            if (botComment) {
              await octokit.issues.updateComment({ owner, repo, comment_id: botComment.id, body });
              console.log("üìù Updated existing review comment.");
            } else {
              await octokit.issues.createComment({ owner, repo, issue_number, body });
              console.log("üÜï Posted new review comment.");
            }
          }

          async function run() {
            const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });
            const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
            
            // üëá OPTIMIZED: Hardcoded model to save API calls (since 2.5-flash works for you)
            const modelName = "gemini-2.5-flash"; 
            const model = genAI.getGenerativeModel({ model: modelName });
            
            const globalRules = await getGlobalRules(process.env.REPO_OWNER);

            console.log(`üöÄ Reviewing with: ${modelName}`);

            // 2. Git Diff
            const baseBranch = process.env.BASE_BRANCH || 'main';
            try { execSync(`git fetch origin ${baseBranch} --depth=1`); } catch (e) {}
            
            // Safety: diff might fail if branch history is weird
            let diff = "";
            try {
                diff = execSync(`git diff origin/${baseBranch}...HEAD`).toString();
            } catch (e) {
                console.warn("Git diff failed. Trying simpler diff...");
                diff = execSync(`git diff HEAD^ HEAD`).toString();
            }

            if (!diff || diff.length < 5) return console.log("No changes detected.");

            // 3. Prompt Construction
            const prompt = `
              You are a Senior Code Reviewer. Review the provided git diff.
              
              ${globalRules}
              
              1. **Summary**: Write a 2-sentence executive summary of what this PR does.
              2. **Issues**: Identify issues and classify them strictly into:
                 - "Bug Risk" (Logical errors, potential crashes) [BLOCKING]
                 - "Security" (Vulnerabilities, secrets, unsafe input) [BLOCKING]
                 - "Performance" (Inefficient loops, blocking sync calls)
                 - "Clean Code" (Naming, formatting, clutter)
                 - "Maintainability" (Complexity, structure)
                 - "Best Practices" (Idiomatic usage)

              Output PURE JSON object (no markdown). Structure:
              {
                "summary": "The summary string...",
                "issues": [{"path": "file", "line": 0, "category": "CategoryName", "body": "comment"}]
              }
              
              DIFF:
              ${diff.substring(0, 30000)}
            `;

            let reviewData = { summary: "No summary available.", issues: [] };
            try {
                 const result = await model.generateContent(prompt);
                 const text = result.response.text().replace(/```json|```/g, "").trim();
                 reviewData = JSON.parse(text);
            } catch (e) {
                console.error("Review generation failed:", e.message);
                // If it fails (e.g. Rate Limit), we exit with error so you know it failed
                process.exit(1); 
            }

            const { summary, issues } = reviewData;

            // 4. Generate Dashboard & Post Comment
            if (issues.length === 0) {
              await postOrUpdateComment(octokit, `## üü© LGTM! \n\n${summary}\n\nNo issues found by **${modelName}**. Great job!`);
            } else {
               // A. Calculate Scores
               const categories = ["Bug Risk", "Security", "Performance", "Clean Code", "Maintainability", "Best Practices"];
               let summaryTable = "| Category | Status | Issues |\n|---|---|---|\n";
               let shouldFailBuild = false;
               let totalIssues = 0;
               
               categories.forEach(cat => {
                   const count = issues.filter(c => c.category === cat).length;
                   let icon = "üü©";
                   totalIssues += count;
                   
                   // Critical Categories turn RED and block the build
                   if (cat === "Bug Risk" || cat === "Security") {
                       if (count > 0) {
                           icon = "üî¥";
                           shouldFailBuild = true;
                       }
                   } else if (count > 0) {
                       icon = "‚ö†Ô∏è";
                   }
                   summaryTable += `| **${cat}** | ${icon} | ${count} |\n`;
               });

               // Limit: Fail if 3+ issues of ANY kind found
               if (totalIssues >= 3) {
                   shouldFailBuild = true;
                   console.log(`‚ùå Blocking merge: ${totalIssues} total issues found (Limit is 2).`);
               }

               // B. Format Details
               let detailsText = "\n### üìù Detailed Review\n";
               issues.forEach(c => {
                   const emoji = c.category === "Security" ? "üîí" : c.category === "Performance" ? "‚ö°" : "üí°";
                   detailsText += `- **${c.path}:${c.line}** (${emoji} ${c.category})\n  ${c.body}\n\n`;
               });

               // C. Construct Body
               const jsonStr = JSON.stringify(issues, null, 2);
               const commentBody = `## ü§ñ AI Code Review \n` +
                                   `> ${summary}\n\n` +
                                   `<sub>Model: ${modelName}</sub>\n\n` +
                                   summaryTable + 
                                   detailsText +
                                   `\n---\n` +
                                   `<details>\n` +
                                   `<summary>üõ†Ô∏è <b>Raw JSON for Auto-Fixer</b></summary>\n\n` +
                                   `\`\`\`json\n${jsonStr}\n\`\`\`\n` +
                                   `</details>`;

               await postOrUpdateComment(octokit, commentBody);

              // D. Block Merge
              if (shouldFailBuild) {
                  console.error("‚ùå Blocking merge due to Critical Issues or Excessive Warnings.");
                  process.exit(1); 
              }
            }
          }
          run().catch(e => { console.error(e); process.exit(1); });
          EOF
          
          node reviewer.js
