name: Reusable Gemini Reviewer

on:
  workflow_call:
    secrets:
      GEMINI_API_KEY:
        required: true

jobs:
  review:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Gemini Libs
        run: npm install @google/generative-ai @octokit/rest

      - name: Run Review
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          REPO_OWNER: ${{ github.repository_owner }}
          REPO_NAME: ${{ github.event.repository.name }}
          BASE_BRANCH: ${{ github.base_ref }}
        run: |
          cat << 'EOF' > reviewer.js
          const { GoogleGenerativeAI } = require("@google/generative-ai");
          const { Octokit } = require("@octokit/rest");
          const { execSync } = require("child_process");

          // ðŸ‘‡ DEFINING THE MODEL LADDER
          const MODEL_PRIORITY = [
            "gemini-2.0-flash",       // 1. Try the smart new one
            "gemini-1.5-flash",       // 2. Fallback to stable
            "gemini-1.5-flash-8b"     // 3. Last resort (High limits)
          ];

          async function generateWithFallback(genAI, prompt) {
            let lastError = null;

            for (const modelName of MODEL_PRIORITY) {
              console.log(`ðŸ¤– Attempting review with model: ${modelName}...`);
              try {
                const model = genAI.getGenerativeModel({ model: modelName });
                
                // timeout promise to prevent hanging
                const timeout = new Promise((_, reject) => 
                    setTimeout(() => reject(new Error("Request timeout")), 30000)
                );

                const result = await Promise.race([
                    model.generateContent(prompt),
                    timeout
                ]);

                console.log(`âœ… Success with ${modelName}!`);
                return { 
                    text: result.response.text(), 
                    usedModel: modelName 
                };

              } catch (error) {
                console.warn(`âŒ Failed with ${modelName}. Error: ${error.message}`);
                // If it's a "Safety" block, waiting won't help, but we try next model anyway.
                // If it's 429 (Rate Limit) or 404 (Not Found), we immediately loop to the next.
                lastError = error;
                // Add a tiny pause between retries to be polite
                await new Promise(r => setTimeout(r, 2000));
              }
            }
            throw new Error(`All models failed. Last error: ${lastError?.message}`);
          }

          async function run() {
            const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });
            const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
            
            // 1. Git Diff Logic
            const baseBranch = process.env.BASE_BRANCH || 'main';
            console.log(`Diffing against origin/${baseBranch}...`);
            try { execSync(`git fetch origin ${baseBranch} --depth=1`); } catch (e) {}

            const diff = execSync(`git diff origin/${baseBranch}...HEAD`).toString();

            if (!diff || diff.length < 5) return console.log("No changes detected.");

            // 2. Prepare Prompt
            const prompt = `
              You are a Senior Code Reviewer. Review the following git diff.
              Identify critical bugs, security issues, and bad practices.
              Output purely a JSON array of objects. No markdown formatting.
              Format: [{"path": "filename", "line": line_number, "body": "comment"}]
              If no issues, output [].
              
              DIFF:
              ${diff.substring(0, 30000)} 
            `;
            
            // 3. CALL GEMINI WITH FALLBACKS
            let response, usedModel;
            try {
                const result = await generateWithFallback(genAI, prompt);
                response = result.text.replace(/```json|```/g, "").trim();
                usedModel = result.usedModel;
            } catch (e) {
                console.error("Review failed:", e);
                process.exit(1);
            }
            
            // 4. Parse & Post
            let comments;
            try { comments = JSON.parse(response); } catch (e) { comments = []; }

            if (comments.length === 0) {
              await octokit.issues.createComment({
                owner: process.env.REPO_OWNER,
                repo: process.env.REPO_NAME,
                issue_number: Number(process.env.PR_NUMBER),
                body: `LGTM! ðŸš€ No issues found. (Reviewed by ${usedModel})`
              });
            } else {
               const jsonStr = JSON.stringify(comments, null, 2);
               const commentBody = `Gemini found ${comments.length} issues.\n` +
                                   `<sub>ðŸ¤– Reviewed by **${usedModel}**</sub>\n\n` +
                                   `<details>\n` +
                                   `<summary>Click to see raw JSON for CLI</summary>\n\n` +
                                   `\`\`\`json\n${jsonStr}\n\`\`\`\n` +
                                   `</details>`;

               await octokit.issues.createComment({
                owner: process.env.REPO_OWNER,
                repo: process.env.REPO_NAME,
                issue_number: Number(process.env.PR_NUMBER),
                body: commentBody
              });
              console.log("Review posted.");
            }
          }
          run().catch(e => { console.error(e); process.exit(1); });
          EOF
          
          node reviewer.js
