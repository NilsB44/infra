name: Reusable Gemini Reviewer

on:
  workflow_call:
    secrets:
      GEMINI_API_KEY:
        required: true

jobs:
  review:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Gemini Libs
        run: npm install @google/generative-ai @octokit/rest

      - name: Run Review
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          REPO_OWNER: ${{ github.repository_owner }}
          REPO_NAME: ${{ github.event.repository.name }}
          BASE_BRANCH: ${{ github.base_ref }}
        run: |
          cat << 'EOF' > reviewer.js
          const { GoogleGenerativeAI } = require("@google/generative-ai");
          const { Octokit } = require("@octokit/rest");
          const { execSync } = require("child_process");

          // üëá 1. AUTO-DISCOVERY FUNCTION
          async function getBestWorkingModel(apiKey) {
            console.log("üîç Auto-discovering available models...");
            try {
                // We fetch the list directly from the API to see what YOUR key can see
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${apiKey}`);
                const data = await response.json();
                
                if (!data.models) throw new Error("No models returned by API.");

                // Filter for models that can generate content
                const availableModels = data.models
                    .filter(m => m.supportedGenerationMethods.includes("generateContent"))
                    .map(m => m.name.replace("models/", "")); // Strip 'models/' prefix

                console.log("üìã Available Models:", availableModels.join(", "));

                // Priority Logic: Try to find specific families in order
                const priorities = [
                    "gemini-1.5-flash",       // Stable Standard
                    "gemini-1.5-flash-001",   // Specific Version
                    "gemini-1.5-pro",         // Stable Pro
                    "gemini-2.0-flash-exp",   // Experimental
                    "gemini-pro"              // Legacy
                ];

                // Find the first priority that exists in your available list
                for (const preferred of priorities) {
                    if (availableModels.includes(preferred)) {
                        return preferred;
                    }
                }

                // Fallback: If none of our favorites exist, just take the first "flash" model found
                const anyFlash = availableModels.find(m => m.includes("flash"));
                if (anyFlash) return anyFlash;

                // Ultimate Fallback: Just take the first valid model
                return availableModels[0];

            } catch (e) {
                console.error("‚ö†Ô∏è Auto-discovery failed:", e.message);
                console.log("Falling back to safe default 'gemini-1.5-flash-latest'");
                return "gemini-1.5-flash-latest";
            }
          }

          async function run() {
            const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });
            const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

            // üëá 2. DYNAMIC MODEL SELECTION
            // Find the correct model name for this specific API Key
            const modelName = await getBestWorkingModel(process.env.GEMINI_API_KEY);
            console.log(`üöÄ Selected Model: ${modelName}`);

            const model = genAI.getGenerativeModel({ model: modelName });

            // 3. Git Logic
            const baseBranch = process.env.BASE_BRANCH || 'main';
            try { execSync(`git fetch origin ${baseBranch} --depth=1`); } catch (e) {}

            const diff = execSync(`git diff origin/${baseBranch}...HEAD`).toString();

            if (!diff || diff.length < 5) return console.log("No changes detected.");

            const prompt = `
              You are a Senior Code Reviewer. Review the following git diff.
              Identify critical bugs, security issues, and bad practices.
              Output purely a JSON array of objects. No markdown formatting.
              Format: [{"path": "filename", "line": line_number, "body": "comment"}]
              If no issues, output [].
              
              DIFF:
              ${diff.substring(0, 30000)} 
            `;
            
            // 4. Generate with Retry logic for Rate Limits (429)
            let responseText;
            try {
                 const result = await model.generateContent(prompt);
                 responseText = result.response.text();
            } catch (error) {
                // If the auto-selected model hits a rate limit (429), we can't easily fix it 
                // without complex logic, so we fail gracefully.
                console.error(`‚ùå Model ${modelName} failed.`);
                console.error(error.message);
                
                // If it was a 429, we print a friendly message
                if (error.message.includes("429")) {
                    console.log("‚ö†Ô∏è You hit the Free Tier rate limit. Try again in a minute.");
                }
                process.exit(1); 
            }

            const response = responseText.replace(/```json|```/g, "").trim();
            
            let comments;
            try { comments = JSON.parse(response); } catch (e) { comments = []; }

            // 5. Post Comments
            if (comments.length === 0) {
              await octokit.issues.createComment({
                owner: process.env.REPO_OWNER,
                repo: process.env.REPO_NAME,
                issue_number: Number(process.env.PR_NUMBER),
                body: `LGTM! üöÄ No issues found. (Reviewed by ${modelName})`
              });
            } else {
               const jsonStr = JSON.stringify(comments, null, 2);
               const commentBody = "Gemini found " + comments.length + " issues.\n" +
                                   "<sub>ü§ñ Reviewed by **" + modelName + "**</sub>\n\n" +
                                   "<details>\n" +
                                   "<summary>Click to see raw JSON for CLI</summary>\n\n" +
                                   "```json\n" + jsonStr + "\n```\n" +
                                   "</details>";

               await octokit.issues.createComment({
                owner: process.env.REPO_OWNER,
                repo: process.env.REPO_NAME,
                issue_number: Number(process.env.PR_NUMBER),
                body: commentBody
              });
              console.log("Review posted.");
            }
          }
          run().catch(e => { console.error(e); process.exit(1); });
          EOF
          
          node reviewer.js
