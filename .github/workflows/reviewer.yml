name: Reusable Gemini Reviewer

on:
  workflow_call:
    secrets:
      GEMINI_API_KEY:
        required: true

jobs:
  review:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Gemini Libs
        run: npm install @google/generative-ai @octokit/rest

      - name: Run Review
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          REPO_OWNER: ${{ github.repository_owner }}
          REPO_NAME: ${{ github.event.repository.name }}
          BASE_BRANCH: ${{ github.base_ref }}
        run: |
          cat << 'EOF' > reviewer.js
          const { GoogleGenerativeAI } = require("@google/generative-ai");
          const { Octokit } = require("@octokit/rest");
          const { execSync } = require("child_process");

          // 1. GLOBAL RULES FETCHER
          async function getGlobalRules(owner) {
            try {
                const url = `https://raw.githubusercontent.com/${owner}/infra/main/GEMINI.md`;
                console.log(`üìñ Fetching global rules from: ${url}`);
                const response = await fetch(url);
                if (!response.ok) return "";
                const text = await response.text();
                return text.length < 10 ? "" : `\n\n### üåç USER-DEFINED GLOBAL STANDARDS\nYou MUST enforce these rules strictly:\n${text}\n`;
            } catch (e) {
                return "";
            }
          }

          // 2. MODEL AUTO-DISCOVERY
          async function getBestWorkingModel(apiKey) {
            console.log("üîç Auto-discovering available models...");
            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${apiKey}`);
                const data = await response.json();
                if (!data.models) throw new Error("No models returned.");
                
                const availableModels = data.models
                    .filter(m => m.supportedGenerationMethods.includes("generateContent"))
                    .map(m => m.name.replace("models/", ""));

                const priorities = ["gemini-1.5-flash", "gemini-1.5-pro", "gemini-2.0-flash-exp", "gemini-pro"];
                for (const p of priorities) { if (availableModels.includes(p)) return p; }
                return availableModels.find(m => m.includes("flash")) || availableModels[0];
            } catch (e) {
                return "gemini-1.5-flash-latest";
            }
          }

          async function run() {
            const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });
            const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
            const modelName = await getBestWorkingModel(process.env.GEMINI_API_KEY);
            const model = genAI.getGenerativeModel({ model: modelName });
            const globalRules = await getGlobalRules(process.env.REPO_OWNER);

            console.log(`üöÄ Reviewing with: ${modelName}`);

            // 3. Git Diff
            const baseBranch = process.env.BASE_BRANCH || 'main';
            try { execSync(`git fetch origin ${baseBranch} --depth=1`); } catch (e) {}
            const diff = execSync(`git diff origin/${baseBranch}...HEAD`).toString();
            if (!diff || diff.length < 5) return console.log("No changes detected.");

            // 4. Prompt
            const prompt = `
              You are a Senior Code Reviewer. Review the provided git diff.
              
              ${globalRules}
              
              1. **Summary**: Write a 2-sentence executive summary of what this PR does.
              2. **Issues**: Identify issues and classify them strictly into:
                 - "Bug Risk" (Logical errors, potential crashes) [BLOCKING]
                 - "Security" (Vulnerabilities, secrets, unsafe input) [BLOCKING]
                 - "Performance" (Inefficient loops, blocking sync calls)
                 - "Clean Code" (Naming, formatting, clutter)
                 - "Maintainability" (Complexity, structure)
                 - "Best Practices" (Idiomatic usage)

              Output PURE JSON object (no markdown). Structure:
              {
                "summary": "The summary string...",
                "issues": [{"path": "file", "line": 0, "category": "CategoryName", "body": "comment"}]
              }
              
              DIFF:
              ${diff.substring(0, 30000)}
            `;

            let reviewData = { summary: "No summary available.", issues: [] };
            try {
                 const result = await model.generateContent(prompt);
                 const text = result.response.text().replace(/```json|```/g, "").trim();
                 reviewData = JSON.parse(text);
            } catch (e) {
                console.error("Review generation failed:", e.message);
                process.exit(1); 
            }

            const { summary, issues } = reviewData;

            // 5. Generate Dashboard
            if (issues.length === 0) {
              await octokit.issues.createComment({
                owner: process.env.REPO_OWNER,
                repo: process.env.REPO_NAME,
                issue_number: Number(process.env.PR_NUMBER),
                body: `## üü© LGTM! \n\n${summary}\n\nNo issues found by **${modelName}**. Great job!`
              });
            } else {
               // A. Calculate Scores
               const categories = ["Bug Risk", "Security", "Performance", "Clean Code", "Maintainability", "Best Practices"];
               let summaryTable = "| Category | Status | Issues |\n|---|---|---|\n";
               let shouldFailBuild = false;
               let totalIssues = 0; // üëá New Counter
               
               categories.forEach(cat => {
                   const count = issues.filter(c => c.category === cat).length;
                   let icon = "üü©";
                   totalIssues += count;
                   
                   // Critical Categories turn RED and block the build
                   if (cat === "Bug Risk" || cat === "Security") {
                       if (count > 0) {
                           icon = "üî¥";
                           shouldFailBuild = true;
                       }
                   } else if (count > 0) {
                       icon = "‚ö†Ô∏è";
                   }
                   summaryTable += `| **${cat}** | ${icon} | ${count} |\n`;
               });

               // üëá NEW: Fail if 3+ issues of ANY kind found
               if (totalIssues >= 3) {
                   shouldFailBuild = true;
                   console.log(`‚ùå Blocking merge: ${totalIssues} total issues found (Limit is 2).`);
               }

               // B. Format Details
               let detailsText = "\n### üìù Detailed Review\n";
               issues.forEach(c => {
                   const emoji = c.category === "Security" ? "üîí" : c.category === "Performance" ? "‚ö°" : "üí°";
                   detailsText += `- **${c.path}:${c.line}** (${emoji} ${c.category})\n  ${c.body}\n\n`;
               });

               // C. Construct Body
               const jsonStr = JSON.stringify(issues, null, 2);
               const commentBody = `## ü§ñ AI Code Review \n` +
                                   `> ${summary}\n\n` +
                                   `<sub>Model: ${modelName}</sub>\n\n` +
                                   summaryTable + 
                                   detailsText +
                                   `\n---\n` +
                                   `<details>\n` +
                                   `<summary>üõ†Ô∏è <b>Raw JSON for Auto-Fixer</b></summary>\n\n` +
                                   `\`\`\`json\n${jsonStr}\n\`\`\`\n` +
                                   `</details>`;

               await octokit.issues.createComment({
                owner: process.env.REPO_OWNER,
                repo: process.env.REPO_NAME,
                issue_number: Number(process.env.PR_NUMBER),
                body: commentBody
              });

              // D. Block Merge
              if (shouldFailBuild) {
                  console.error("‚ùå Blocking merge due to Critical Issues or Excessive Warnings.");
                  process.exit(1); 
              }
            }
          }
          run().catch(e => { console.error(e); process.exit(1); });
          EOF
          
          node reviewer.js
